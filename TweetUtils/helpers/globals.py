import astimport reimport datetimefrom TweetUtils.database import MySQLDatabaseConnectorfrom nltk.corpus.reader.wordnet import NOUN, VERB, ADJ, ADVimport loggingimport inspectimport os__author__ = 'maria'# pattern source 'http://stackoverflow.com/questions/3895874/regex-to-match-lol-to-lolllll-and-omg-to-omggg-etc'# '''LAUGHING_PATTERN_lol = """(?ix)\b    # assert position at a word boundary#     (?=l(o)*(l)*)        # assert that "lol" can be matched here#     \S*            # match any number of characters except whitespace#     (\S+)          # match at least one character (to be repeated later)#     (?<=\blo)     # until we have reached exactly the position after the 1st "lol"#     \1*            # then repeat the preceding character(s) any number of times#     \b             # and ensure that we end up at another word boundary"""'''class Globals(object):    """    General purpose class to hold global variables, such as db connection and logger instance.    """    def __init__(self):        self.train_model = {}        self.logger = None        self.handler = None        self.formatter = None        self.mysql_conn = None        self.NOUNS = ['N', 'NP', 'NN', 'NNS', 'NNP', 'NNPS']        self.VERBS = ['V', 'VD', 'VG', 'VN', 'VB', 'VBD', 'VBG', 'VBN', 'VBP', 'VBZ']        self.ADJECTIVES = ['ADJ', 'JJ', 'JJR', 'JJS']        self.ADVERBS = ['RB', 'RBR', 'RBS', 'WRB']        self.LINK_PATTERN = r'(?P<url>https?://[^\s]+)'        self.HT_PATTERN = r'#\w+'        self.RT_PATTERN = r'\b(^RT:{0,1}|rt:{0,1})\b'        self.LAUGHING_PATTERN_haha = '\b(a?((h)*(a)*)*)\b'        self.LAUGHING_PATTERN_lol= '(?ix)\b(l(o)*(l)*)\1*\b'        self.LAUGHING_PATTERN_rotfl = '(?ix)\b(?=ro(t)*fl)'        self.LAUGHING_PATTERN_omg = '(?ix)\b(?=o(m)*(g)*)'        self.LAUGH_PATTERN = r'\b(a*ha+h[ha]*|o?l+o+l+[ol]*)\b'        self.POS_SMILEY_PATTERN = r'(:-\)|:-D|:-\)\)|:\)\)|\(:|:\)|:D|=\)|;-\)|XD|=D|=]|;D|:]|:o\))'        self.NEG_SMILEY_PATTERN = r'(:-\\|:-\(|:-\(\(|:\(|:o|:O|D:|=/|=\(|:\'\(|:\'-\(|:\\|:/|:S)'  # bug fix: ! --> |        self.SMILEY_FULL_PATTERN = '(:-\)|:-\(|:-\(\(|:-D|:-\)\)|:\)\)|\(:|:\(|:\)|:D|=\)|;-\)|XD|=D|:o|' \                                   ':O|=]|D:|;D|:]|=/|=\(!:\'\(|:\'-\(|:\\|:/|:S|<3)'        self.NEGATIONS_PATTERN = r'\b#{0,1}(no|not|isnt|isn\'t|isn;t|don\'t|won\'t|couldn\'t|can\'t|didn\'t|not|didnt|didn;t' \                                 r'|dont|don;t|don t|won t|can;t|cant|can t|doesn\'t|doesnt|doesn t|doesn;t|cannot|did not|not)\b'        self.CAPITALS_PATTERN = r'\b[A-Z]{3,}\b'        self.REFERENCE_PATTERN = r'(@\w+|@\D\w+|@\d\w+)'        self.LOVE_PATTERN = r'(<3|&lt;3)'        self.NEGATIONS = ['no', 'don\'t', 'won\'t', 'couldn\'t', 'can\'t', 'didn\'t', 'not', 'could not', 'cannot']        self.OH_SO_PATTERN = r'(O|o)h,?\s?(so)?\s?(you)?\w+'        self.DONT_YOU_PATTERN = r'(D|d)on\'?;?\s?t\s(you|u)'        self.AS_GROUND_AS_VEHICLE_PATTERN = r'(A|a)s\s\w+\sas\s\w+\s?'        self.MUST_KNOW_ABBREV = ['RT', 'MT', 'DM', 'FF', '@reply']        self.pos_literal = {'n': NOUN,                            'v': VERB,                            'a': ADJ,                            'r': ADV}        self.ROOT_PATH = os.path.dirname(os.path.realpath(__file__))        self.PROJECT_ROOT_PATH = str(self.ROOT_PATH).replace('helpers','')        self.TWITTIE_JAR_PATH = self.PROJECT_ROOT_PATH + '/data/twitie-tagger/twitie_tag.jar'        self.TWITTIE_MODEL_PATH = self.PROJECT_ROOT_PATH + '/data/twitie-tagger/models/gate-EN-twitter.model'        self.DATESTAMP = str(datetime.datetime.today()).replace(' ', '_').replace(':', '_')        self.log_separator = "#################################{0}####################################################"        self.LOG_PATH = self.PROJECT_ROOT_PATH + "/logs/"        self.LOG_FILE_PATH = self.LOG_PATH +"tweet_utils{0}.logs".format(self.DATESTAMP)        self._init_enums()        self._init_logger()        self._init_db_handlers()        self._prepare_gate_pos_tags_model()    def _prepare_gate_pos_tags_model(self):        # stored processed model as a dict in file so to minimize load time        with open(self.PROJECT_ROOT_PATH+'data/model_dict.txt', 'r') as f:            self.train_model = ast.literal_eval(f.read())# ================================================ LOGGER  ============================================================#    def _init_logger(self):        self.logger = logging.getLogger('baulogger')        if not os.path.exists(self.LOG_PATH):            os.makedirs(self.LOG_PATH)        self.handler = logging.FileHandler(self.LOG_FILE_PATH)        self.formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')        self.handler.setFormatter(self.formatter)        self.logger.addHandler(self.handler)        self.logger.setLevel(logging.DEBUG)    def autolog(self, message):        """        Automatically logs the current function details.        source:        http://stackoverflow.com/questions/10973362/python-logging-function-name-file-name-line-number-using-a-single-file        """        # Get the previous frame in the stack, otherwise it would        # be this function!!!        func = inspect.currentframe().f_back.f_code        # Dump the message + the name of this function to the logs.        self.logger.debug("%s: %s in %s:%i" % (            message,            func.co_name,            func.co_filename,            func.co_firstlineno        ))    def _init_db_handlers(self):        try:            self.mysql_conn = MySQLDatabaseConnector()        except:            self.logger.error("Could not instantiate mysql")# ================================================ ENUMS  =============================================================#    @staticmethod    def enum(*sequential, **named):        """        REFERENCE = http://stackoverflow.com/questions/36932/how-can-i-represent-an-enum-in-python        """        enums = dict(zip(sequential, range(len(sequential))), **named)        reverse = dict((value, key) for key, value in enums.iteritems())        enums['name'] = reverse        return type('Enum', (), enums)    def _init_enums(self):        self.DB_TYPE = Globals.enum(MYSQL=0, MSSQL=1, MONGODB=2)        self.DATA_TYPE = Globals.enum(TWITTER_CORPUS=0, SWN=1, STOP_WORDS=2, EMOTICONS=3)        self.TABLE = Globals.enum(TwitterCorpus=0, TwitterCorpusV2=1, ManualTwitterCorpus=2, TwitterCorpusNoEmoticons=3,                                  FigurativeTrainingData=4)        self.SOURCE = Globals.enum(Corpus=0, Text=1, Stream=2)        self.CLASSIFIER_TYPE = Globals.enum(NBayes=0, SVM=1, DecisionTree=2, SVMStandalone=3, SVR=4, NuSVR=5,                                            RandomForestRegressor=6, SGD=7, SVC=8)        self.TAGS = Globals.enum(__CAPITAL__=0,                                 __HT__=1,                                 __HT_POS__=2,                                 __HT_NEG__=3,                                 __LINK__=4,                                 __POS_SMILEY__=5,                                 __NEG_SMILEY__=6,                                 __NEGATION__=7,                                 __REFERENCE__=8,                                 __RT__=9,                                 __LAUGH__=10,                                 __LOVE__=11,                                 __OH_SO__=12,                                 __DONT_YOU__=13,                                 __AS_GROUND_AS_VEHICLE__=14,                                 __questionmark__=15,                                 __fullstop__=16,                                 __exclamation__=17)        self.VALUE_TYPES = Globals.enum(Boolean=0, Text_boolean=1, Text=2, Count=3)        # Globals for Evaluation of results #        self.METHOD_TYPE = Globals.enum(GENERAL=0, ASPECT_BASED=1, GEO_BASED=2)        # Globals for Statistics #        self.STATS_TYPE = Globals.enum(TEXT_AND_SCORE=0, METHOD_AND_ACCURACY=1 )        self.CHART_TYPE = Globals.enum(BAR=0, PIE=1)        # Globals for Aspect Analysis #        self.WORD_TYPE = Globals.enum(NOUN=0, VERB=1, ADJECTIVE=2, ADVERB=3)        # Globals for Threading Jobs #        self.JOB = Globals.enum(STOP=0, START=1)        self.DISCRETIZATION = Globals.enum(ONE=1.0, HALF=0.5, ZERO_POINT_TWO=0.2)# ================================================ SQL  ===============================================================#    @staticmethod    def select_from_stop_words():        return "SELECT StopWord FROM SentiFeed.StopWordsSample"    @staticmethod    def sum_query_figurative_scale_equals():        return '''SELECT                    CASE                        WHEN count(SentimentAssesment) > 0                        THEN sum(SentimentAssesment) / count(SentimentAssesment)                        ELSE 10                    END AS SWN                FROM                    SentiFeed.SentiWordNet                where                    SysTerms = '{0}' {1};'''    @staticmethod    def sum_query_figurative_scale_equals_rank_test():        return ''' SELECT sum(SentimentAssesment),sum(rank)                   FROM sentifeed.sentiwordnet                   where SysTerms = '{0}' {1}                   GROUP BY sentiwordnet.SentiWordNetTempId;'''    @staticmethod    def sum_query_figurative_scale_like_rank_test():        return ''' SELECT sum(SentimentAssesment),sum(rank)                   FROM sentifeed.sentiwordnet                   where SysTerms LIKE '{0}%' {1}                   GROUP BY sentiwordnet.SentiWordNetTempId;'''    @staticmethod    def sum_query_figurative_scale_equals():        return '''SELECT                    CASE                        WHEN count(SentimentAssesment) > 0                        THEN sum(SentimentAssesment) / count(SentimentAssesment)                        ELSE 10                    END AS SWN                FROM                    SentiFeed.SentiWordNet                where                    SysTerms = '{0}' {1};'''    @staticmethod    def sum_query_figurative_scale_like():        return '''SELECT                    CASE                        WHEN count(SentimentAssesment) > 0                        THEN sum(SentimentAssesment) / count(SentimentAssesment)                        ELSE 10                    END AS SWN                FROM                    SentiFeed.SentiWordNet                where                    SysTerms like '{0}%' {1};'''    @staticmethod    def sum_query_figurative_scale2_equals():        return '''SELECT CASE                            WHEN count(ConvertedScale)>0                            THEN sum(ConvertedScale)/count(ConvertedScale)                            ELSE 10                            END AS SWN                    FROM SentiFeed.SentiWordNet                    where SysTerms = "{0}" {1}'''    @staticmethod    def sum_query_figurative_scale2_like():        return '''SELECT CASE                            WHEN count(ConvertedScale)>0                            THEN sum(ConvertedScale)/count(ConvertedScale)                            ELSE 10                            END AS SWN                    FROM SentiFeed.SentiWordNet                    where SysTerms like "{0}%" {1}'''# Singleton-likesg = Globals()